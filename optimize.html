<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="utf-8">
		<title>前端性能优化</title>
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="shortcut icon" href="favicon.ico" type=”image/x-icon”>
		<link rel="stylesheet" href="css/main.css">
	</head>
	<body>
		<nav>
			<ul>
				<li><a href="index.html">Home</a></li>
				<li><a href="demo.html">前端作品</a></li>
				<li><a href="">日志</a></li>
			</ul>
		</nav>
		<div class="container">
			<h1>前端性能优化</h1>
			<p>data</p>
      <p>Yahoo!的 Exceptional Performance团队为改善 Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。</p>
      <p>Excetional Performance 团队总结出了一系列可以提高网站速度的方法。可以分为 7大类 35条。包括<a href="#content">内容</a> 、<a href="#server">服务器</a> 、 <a href="#css">CSS</a> 、 <a href="#js">JavaScript</a> 、<a href="#cookie">Cookie</a> 、<a href="#imge">图片</a> 、<a href="#mobile">Mobile部分</a> ，七部分。</p>
			<h3 id="content">一、内容部分</h3>
      <ul>
        <li>尽量减少HTTP请求</li>
        <li>减少DNS查找</li>
        <li>避免跳转</li>
        <li>缓存Ajxa</li>
        <li>推迟加载</li>
        <li>提前加载</li>
        <li>减少DOM元素数量</li>
        <li>用域名划分页面内容</li>
        <li>使frame数量最少</li>
        <li>避免404错误</li>
      </ul>
      <h4>1、尽量减少HTTP请求</h4>
      <p>终端用户响应的时间中，有80%用于下载各项内容。这部分时间包括下载页面中的图像、样式表、脚本、 Flash等。通过减少页面中的元素可以减少 HTTP请求的次数。这是提高网页速度的关键步骤。</p>
      <p>合并文件是通过把所有的脚本放到一个文件中来减少HTTP请求的方法，如可以简单地把所有的 CSS文件都放入一个样式表中。当脚本或者样式表在不同页面中使用时需要做不同的修 改，这可能会相对麻烦点，但即便如此也要把这个方法作为改善页面性能的重要一步。</p>
      <p>CSS Sprites是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过 CSS的 background-image和 background-position属性来显示图片的不同部分；</p>
      <h4>2、减少DNS查找</h4>
      <p>缓存 DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的ISP提供商或者本地局域网控制，但是它同样会在用户使用的计算机上产生缓存。 DNS信息会保留在操作系统的 DNS缓存中（微软 Windows系统中 DNS Client Service）。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。</p>
      <p>减少主机名的数量还可以减少页面中并行下载的数量。减少DNS查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的指导原则是把这些页面中的内容分割成至少两部分但不超过四部分。这种结果就是在减少DNS查找次数和保持较高程度并行下载两者之间的权衡了。</p>
      <h4>3、避免跳转</h4>
      <p>跳转会降低用户体验。在用户和HTML文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在 HTML文件被加载前任何文件（图像、 Flash等）都不会被下载。</p>
      <h4>4、缓存Ajxa</h4>
      <p>使用 Ajax并不能保证用户不会在等待异步的JavaScript和XML响应上花费时间。在很多应用中，用户是否需要等待响应取决于Ajax如何来使用。为了提高性能，优化Ajax响应是很重要的。提高 Ajxa性能的措施中最重要的方法就是使响应具有可缓存性。</p>
      <h4>5、推迟加载内容</h4>
      <p>你可以仔细看一下你的网页，问问自己“哪些内容是页面呈现时所必需首先加载的？哪些内容和结构可以稍后再加载？</p>
      <p>把整个过程按照 onload事件分隔成两部分，JavaScript是一个理想的选择。例如，如果你有用于实现拖放和动画的JavaScript，那么它就以等待稍后加载，因为页面上的拖放元素是在初始化呈现 之后才发生的。其它的例如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以推迟加载。</p>
      <h4>6、预加载</h4>
      <p>预加载和推迟加载看起来似乎恰恰相反，但实际上预加载是为了实 现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚本）。使用这种方法，当用户要访问下一个页面时，页面中的内容大部分已经加载到缓存中了，因此可以大大改善访问速度。</p>
      <p>下面提供了几种预加载方法：</p>
      <p>无条件加载：触发onload事件时，直接加载额外的页面内容。以Google.com为例，你可以看一下它的 spirit image图像是怎样在 onload中加载的。这个 spirit image图像在google.com主页中是不需要的，但是却可以在搜索结果页面中用到它。</p>
      <p>有条件加载：根据用户的操作来有根据地判断用户下面可能去往的页面并相应的预加载页面内容。在 search.yahoo.com中你可以看到如何在你输入内容时加载额外的页面内容。</p>
      <p>有预期的加载：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨“新的页面看起来很酷，但是却比以前慢”。问题可能出在 用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部内容来避免这种结果的出现。在你的旧站中利用浏览器的空余时间加载新站中用到的图像的和脚本来提高访问速度。</p>
      <h4>7、减少 DOM元素数量</h4>
      <p>一个复杂的页面意味着需要下载更多数据，同时也意味着 JavaScript遍历 DOM的效率越慢。比如当你增加一个事件句柄时在500和5000个DOM元素中循环效果肯定是不一样的。</p>
      <h4>8、根据域名划分页面内容</h4>
      <p>把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于 DNS查找带来的影响你首先要确保你使用的域名数量在2个到4个之间。例如，你可以把用到的HTML内容和动态内容放在 http://www.example.org/ 上，而把页面各种组件（图片、脚本、 CSS)分别存放在 statics1.example.org和 statics.example.org上。</p>
      <h4>9、使 iframe的数量最小</h4>
      <p>ifrmae 元素可以在父文档中插入一个新的HTML文档。了解iframe的工作理然后才能更加有效地使用它，这一点很重要。</p>
      <h4>10、不要出现404错误</h4>
      <p>HTTP 请求时间消耗是很大的，因此使用 HTTP请求来获得一个没有用处的响应（例如 404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。</p>
      <h3 id="server">二、服务器部分</h3>
      <ul>
        <li>使用内容分发网络</li>
        <li>为文件头指定Expires或Cache-Control</li>
        <li>Gzip压缩文件内容</li>
        <li>配置ETag</li>
        <li>尽早刷新输出缓冲</li>
        <li>使用GET来完成AJAX请求</li>
        <li>避免空的图像来源</li>
      </ul>
      <h4>11、使用内容分发网络</h4>
      <p>内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据 和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。</p>
      <p>在终端用户的响应时间中有80%到90%的响应时间用于下载图像、样式表、脚本、Flash等页面内容。这就是网站性能黄金守则。和重新设计你的 应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。</p>
      <h4>12、为文件头指定Expires或Cache-Control</h4>
      <p>这条守则包括两方面的内容：</p>
      <p>对于静态内容：设置文件头过期时间Expires的值为“Never expire”（永不过期）</p>
      <p>对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求</p>
      <h4>13、Gzip压缩文件内容</h4>
      <p> Gzip是目前最流行也是最有效的压缩方式。这是由GNU项目开发并通过RFC 1952来标准化的。</p>
      <p>Gzip大概可以减少70%的响应规模。目前大约有90%通过浏览器传输的互联网交换支持gzip格式。如果你使用的是Apache，gzip模块配置和 你的版本有关：Apache 1.3使用mod_zip，而Apache 2.x使用moflate。</p>
      <p>服务器根据文件类型来选择需要进行gzip压缩的文件，但是这过于限制了可压缩的文件。大多数web服务器会压缩HTML文档。对脚本和样式表进行压缩同 样也是值得做的事情，但是很多web服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括XML和JSON，都值得的。图像和PDF文件由于 已经压缩过了所以不能再进行gzip压缩。如果试图gizp压缩这些文件的话不但会浪费CPU资源还会增加文件的大小。 </p>
      <h4>14、配置ETag</h4>
      <p>Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等）。增加ETag为实体的验证提供了一个比使用“last-modified date（上次编辑时间）”更加灵活的机制。Etag是一个识别内容版本号的唯一字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有 ETag文件头的响应指定页面内容的ETag。 </p>
      <h4>15、尽早刷新输出缓冲</h4>
      <h4>16、使用GET来完成AJAX请求</h4>
      <p>Yahoo!Mail团队发现，当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数 据。因此使用GET最为恰当，因为它只需发送一个TCP包（除非你有很多cookie）。IE中URL的最大长度为2K，因此如果你要发送一个超过2K的 数据时就不能使用GET了。</p>
      <p>一个有趣的不同就是POST并不像GET那样实际发送数据。根据HTTP规范，GET意味着“获取”数据，因此当你仅仅获取数据时使用GET更加有意义（从语意上讲也是如此），相反，发送并在服务端保存数据时使用POST。</p>
      <h4>17、避免空的图像来源</h4>
      <p>一个src属性为空串的图像,浏览器会再次向你的服务器发出请求。</p>
      <h3 id="css">三、CSS部分</h3>
      <ul>
        <li>把样式表置于顶部</li>
        <li>避免使用CSS表达式（）</li>
        <li>用&lt;link&gt;代替@import</li>
        <li>避免使用滤镜</li>
      </ul>
      <h4>18、把样式表置于顶部</h4>
      <h4>19、避免使用CSS表达式（）</h4>
      <h4>20、用&lt;link&gt;代替@import</h4>
      <h4>21、避免使用滤镜</h4>
      <p>IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的 呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。</p>
      <p>完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。</p>
      <h3 id="js">四、 JavaScript部分</h3>
      <ul>
        <li>把脚本置于页面底部</li>
        <li>使用外部JavaScript和CSS</li>
        <li>削减JavaScript和CSS</li>
        <li>剔除重复脚本</li>
        <li>减少DOM访问 </li>
        <li>开发智能事件处理程序</li>
      </ul>
      <h4>22、把脚本置于页面底部</h4>
      <h4>23、使用外部JavaScript和CSS</h4>
      <h4>24、削减JavaScript和CSS</h4>
      <h4>25、剔除重复脚本</h4>
      <h4>26、减少DOM访问</h4>
      <p>使用JavaScript访问DOM元素比较慢，因此为了获得更多的应该页面，应该做到</p>：
      <p>缓存已经访问过的有关元素 </p>
      <p>线下更新完节点之后再将它们添加到文档树中 </p>
      <p>避免使用JavaScript来修改页面布局 </p>
      <h4>27、开发智能事件处理程序</h4>
      <p>有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。</p>
      <p>你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。</p>
      <h3 id="cookie">五、Cookie部分</h3>
      <ul>
        <li>减小Cookie体积</li>
        <li>对于页面内容使用无coockie域名</li>
      </ul>
      <h4>28、减小Cookie体积</h4>
      <p>HTTP coockie可以用于权限验证和个性化身份等多种用途。coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。因此保持coockie尽可能的小以减少用户的响应时间十分重要。</p>
      <h4>29、对于页面内容使用无coockie域名</h4>
      <p>当浏览器在请求中同时请求一张静态的图片和发送coockie时，服务器对于这些coockie不会做任何地使用。因此他们只是因为某些负面因素而创建的 网络传输。所有你应该确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。</p>
      <h3 id="imge">六、Image 部分</h3>
      <ul>
        <li>优化图像</li>
        <li>优化CSS Spirite</li>
        <li>不要在HTML中缩放图像</li>
        <li>favicon.ico要小而且可缓存</li>
      </ul>
      <h4>30、优化图像</h4>
      <p>设计人员完成对页面的设计之后，不要急于将它们上传到web服务器，这里还需要做几件事：</p>
      <p>你可以检查一下你的GIF图片中图像颜色的数量是否和调色板规格一致。</p> 
      <p>使用imagemagick中下面的命令行很容易检查：</p>
      <code>identify -verbose image.gif </code>
      <p>如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。</p>
      <p>尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。由于浏览器支持有限，设计者们往往不太乐意使用PNG格式的图片，不过 这都是过去的事情了。现在只有一个问题就是在真彩PNG格式中的alpha通道半透明问题，不过同样的，GIF也不是真彩格式也不支持半透明。因此GIF能做到的，PNG（PNG8）同样也能做到（除了动画）。下面这条简单的命令可以 安全地把GIF格式转换为PNG格式：</p>
      <code>convert image.gif image.png</code>
      <p>“我们要说的是：给PNG一个施展身手的机会吧！”  在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如：</p>
     <code> pngcrush image.png -rem alla -reduce -brute result.png </code>
      <p>在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 （如EXIF信息）：</p>
      <code>jpegtran -copy none -optimize -perfect src.jpg dest.jpg</code>
      <h4>31、优化CSS Spirite</h4>
      <p>在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；  便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100x100的图片为1万像素，而1000x1000就是100万像素。</p>
      <h4>32、不要在HTML中缩放图像</h4>
      <p>不要为了在HTML中设置长宽而使用比实际需要大的图片。</p>
      <h4>33、favicon.ico要小而且可缓存</h4>
      <p>文件尽量地小，最好小于1K。在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地 把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。</p>
      <h3 id="mobile">七、 Mobile部分</h3>
      <ul>
        <li>保持单个内容小于25K</li>
        <li>打包组件成复合文本</li>
      </ul>
      <h4>34、保持单个内容小于25K</h4>
      <p>这条限制主要是因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重要。</p>
      <h4>35、打包组件成复合文本</h4>
      <p>把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规则时，首先要确定用户代理是否支持（iPhone就不支持）。</p>
	</body>
</html>